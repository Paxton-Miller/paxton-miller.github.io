<h2 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h2><p>{% asset_img “Pasted image 20260104095912.png” “Pasted image 20260104095912.png” %}<br>磁盘块<br>{% asset_img “Pasted image 20260104113057.png” “Pasted image 20260104113057.png” %}</p>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>{% asset_img “Pasted image 20260104103654.png” “Pasted image 20260104103654.png” %}<br>{% asset_img “Pasted image 20260104103516.png” “Pasted image 20260104103516.png” %}<br>{% asset_img “Pasted image 20260104103821.png” “Pasted image 20260104103821.png” %}<br>{% asset_img “Pasted image 20260104103934.png” “Pasted image 20260104103934.png” %}<br>{% asset_img “Pasted image 20260104103952.png” “Pasted image 20260104103952.png” %}<br>{% asset_img “Pasted image 20260104104200.png” “Pasted image 20260104104200.png” %}</p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>{% asset_img “Pasted image 20260104112307.png” “Pasted image 20260104112307.png” %}<br>无环图目录结构的应用：硬链接<br>{% asset_img “Pasted image 20260104112518.png” “Pasted image 20260104112518.png” %}<br>FCB&#x2F;目录项<br>{% asset_img “Pasted image 20260104112604.png” “Pasted image 20260104112604.png” %}<br>当前目录&#x2F;根目录的磁盘IO对比<br>{% asset_img “Pasted image 20260104112637.png” “Pasted image 20260104112637.png” %}<br>{% asset_img “Pasted image 20260104112837.png” “Pasted image 20260104112837.png” %}<br>磁盘IO次数对比，文件检索速度更加快捷（索引节点调入内存、外存索引节点、内存索引节点）<br>{% asset_img “Pasted image 20260104112933.png” “Pasted image 20260104112933.png” %}<br>需要时从外存调指定目录项的索引结点</p>
<h2 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h2><p>注意页号和内存块号的区别，类比文件的逻辑块和物理块<br>{% asset_img “Pasted image 20260104155305.png” “Pasted image 20260104155305.png” %}</p>
<p>Q：怎么把逻辑块号转换为物理块号？</p>
<h3 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h3><p>{% asset_img “Pasted image 20260104155356.png” “Pasted image 20260104155356.png” %}<br>{% asset_img “Pasted image 20260104155455.png” “Pasted image 20260104155455.png” %}<br>为什么顺序访问速度最快？因为磁头（？）移动间隔很小，开小很小</p>
<h3 id="链接分配方式"><a href="#链接分配方式" class="headerlink" title="链接分配方式"></a>链接分配方式</h3><p>{% asset_img “Pasted image 20260104155610.png” “Pasted image 20260104155610.png” %}<br>{% asset_img “Pasted image 20260104155740.png” “Pasted image 20260104155740.png” %}<br>{% asset_img “Pasted image 20260104155814.png” “Pasted image 20260104155814.png” %}<br>{% asset_img “Pasted image 20260104155823.png” “Pasted image 20260104155823.png” %}</p>
<h4 id="0-随机访问与顺序访问"><a href="#0-随机访问与顺序访问" class="headerlink" title="0.随机访问与顺序访问"></a>0.随机访问与顺序访问</h4><p>随机访问：物理地址&#x3D;起始地址+(逻辑索引×元素大小)</p>
<p>虽然显式链接（如 FAT 文件系统）在理论数据结构上仍然是“链表”（意味着你需要顺藤摸瓜），但由于这个链表被提取出来单独存放在<strong>内存</strong>中，因此在实际效果上，它实现了（近似的）随机访问。</p>
<h4 id="1-隐式链接（普通链表）：必须读盘才能找到路"><a href="#1-隐式链接（普通链表）：必须读盘才能找到路" class="headerlink" title="1. 隐式链接（普通链表）：必须读盘才能找到路"></a>1. 隐式链接（普通链表）：必须读盘才能找到路</h4><p>在隐式链接中，指向下一个块的指针是<strong>存储在数据块内部的</strong>。</p>
<ul>
<li><p><strong>场景：</strong> 你要读取文件的第 100 个块。</p>
</li>
<li><p><strong>过程：</strong></p>
<ol>
<li><p>读取第 1 块（磁盘 I&#x2F;O），在末尾拿到第 2 块的地址。</p>
</li>
<li><p>读取第 2 块（磁盘 I&#x2F;O），在末尾拿到第 3 块的地址。</p>
</li>
<li><p>…</p>
</li>
<li><p>读取第 99 块（磁盘 I&#x2F;O），在末尾拿到第 100 块的地址。</p>
</li>
<li><p>读取第 100 块。</p>
</li>
</ol>
</li>
<li><p><strong>代价：</strong> 你为了找到第 100 块，被迫进行了 99 次<strong>磁盘读操作</strong>。</p>
</li>
<li><p><strong>结论：</strong> 极其缓慢，完全不支持随机访问。</p>
</li>
</ul>
<h4 id="2-显式链接（FAT）：地图在内存里"><a href="#2-显式链接（FAT）：地图在内存里" class="headerlink" title="2. 显式链接（FAT）：地图在内存里"></a>2. 显式链接（FAT）：地图在内存里</h4><p>在显式链接中，所有的指针被提取出来，存放在一张集中的表中（FAT表，File Allocation Table）。<strong>关键点在于：系统启动时，这张表通常会被加载到内存中。</strong></p>
<ul>
<li><p><strong>场景：</strong> 你还是要读取文件的第 100 个块。</p>
</li>
<li><p><strong>过程：</strong></p>
<ol>
<li><p>CPU 在<strong>内存</strong>中的 FAT 表里查看：<code>Entry[1]</code> 指向 5。</p>
</li>
<li><p>CPU 继续在<strong>内存</strong>里看：<code>Entry[5]</code> 指向 12…</p>
</li>
<li><p>CPU 瞬间在<strong>内存</strong>里遍历完这 99 个节点的链条，找到了第 100 块的物理地址是 888。</p>
</li>
<li><p><strong>直接驱动磁头去读取物理块 888。</strong></p>
</li>
</ol>
</li>
<li><p><strong>代价：</strong> 99 次<strong>内存访问</strong> + 1 次<strong>磁盘读操作</strong>。</p>
</li>
<li><p><strong>结论：</strong></p>
<ul>
<li><p>内存访问的速度是纳秒级（ns）。</p>
</li>
<li><p>磁盘访问的速度是毫秒级（ms）。</p>
</li>
<li><p>两者相差几十万倍。</p>
</li>
</ul>
</li>
</ul>
<h3 id="索引分配方式"><a href="#索引分配方式" class="headerlink" title="索引分配方式"></a>索引分配方式</h3><p>{% asset_img “Pasted image 20260104165809.png” “Pasted image 20260104165809.png” %}<br>{% asset_img “Pasted image 20260104170226.png” “Pasted image 20260104170226.png” %}<br>{% asset_img “Pasted image 20260104170306.png” “Pasted image 20260104170306.png” %}<br>{% asset_img “Pasted image 20260104170354.png” “Pasted image 20260104170354.png” %}<br>{% asset_img “Pasted image 20260104170416.png” “Pasted image 20260104170416.png” %}<br>{% asset_img “Pasted image 20260104165955.png” “Pasted image 20260104165955.png” %}</p>
<h2 id="逻辑结构VS物理结构"><a href="#逻辑结构VS物理结构" class="headerlink" title="逻辑结构VS物理结构"></a>逻辑结构VS物理结构</h2><p>{% asset_img “Pasted image 20260105144350.png” “Pasted image 20260105144350.png” %}<br>两个典型例子：<br>逻辑上顺序文件的链式存储在物理上用连续&#x2F;链接&#x2F;索引分配<br>{% asset_img “Pasted image 20260105144753.png” “Pasted image 20260105144753.png” %}<br>逻辑上索引文件在物理上用索引分配<br>{% asset_img “Pasted image 20260105144833.png” “Pasted image 20260105144833.png” %}<br>{% asset_img “Pasted image 20260105144513.png” “Pasted image 20260105144513.png” %}{% asset_img “Pasted image 20260105144524.png” “Pasted image 20260105144524.png” %}{% asset_img “Pasted image 20260105144539.png” “Pasted image 20260105144539.png” %}</p>
<h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p>{% asset_img “Pasted image 20260105155047.png” “Pasted image 20260105155047.png” %}<br>{% asset_img “Pasted image 20260105155858.png” “Pasted image 20260105155858.png” %}<br>{% asset_img “Pasted image 20260105155917.png” “Pasted image 20260105155917.png” %}<br>{% asset_img “Pasted image 20260105155937.png” “Pasted image 20260105155937.png” %}<br>{% asset_img “Pasted image 20260105160216.png” “Pasted image 20260105160216.png” %}<br>{% asset_img “Pasted image 20260105160619.png” “Pasted image 20260105160619.png” %}<br>{% asset_img “Pasted image 20260105160645.png” “Pasted image 20260105160645.png” %}<br>{% asset_img “Pasted image 20260105160718.png” “Pasted image 20260105160718.png” %}<br>成组链接超级块常驻内存，怎么进行回收和分配？<br>分配：分配1块，直接切出去201号磁盘块，100变为99<br>分配100块，切出整个超级块，把块号300对应的分组拷贝到超级块中<br>回收：假设上限100，现在回收1块，新增一个分组作为超级块，第一个指向老的超级块，第二个是新的回收的1块</p>
<h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p>{% asset_img “Pasted image 20260105165654.png” “Pasted image 20260105165654.png” %}</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>{% asset_img “Pasted image 20260105165933.png” “Pasted image 20260105165933.png” %}<br>{% asset_img “Pasted image 20260105170233.png” “Pasted image 20260105170233.png” %}</p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p>{% asset_img “Pasted image 20260105170940.png” “Pasted image 20260105170940.png” %}</p>
<h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p>{% asset_img “Pasted image 20260105171345.png” “Pasted image 20260105171345.png” %}</p>
<h2 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h2><p>{% asset_img “Pasted image 20260105215327.png” “Pasted image 20260105215327.png” %}<br>{% asset_img “Pasted image 20260105215357.png” “Pasted image 20260105215357.png” %}<br>{% asset_img “Pasted image 20260105215542.png” “Pasted image 20260105215542.png” %}<br>文件句柄可以理解为读写时的指针，文件记录号&#x2F;文件描述符</p>
<h2 id="虚拟文件系统VFS"><a href="#虚拟文件系统VFS" class="headerlink" title="虚拟文件系统VFS"></a>虚拟文件系统VFS</h2><p>{% asset_img “Pasted image 20260105221452.png” “Pasted image 20260105221452.png” %}<br>{% asset_img “Pasted image 20260105221506.png” “Pasted image 20260105221506.png” %}<br>{% asset_img “Pasted image 20260105221528.png” “Pasted image 20260105221528.png” %}<br>{% asset_img “Pasted image 20260105221548.png” “Pasted image 20260105221548.png” %}<br>{% asset_img “Pasted image 20260105221623.png” “Pasted image 20260105221623.png” %}</p>
<h2 id="文件系统对比"><a href="#文件系统对比" class="headerlink" title="文件系统对比"></a>文件系统对比</h2><p>我们可以把文件系统分为三类：<strong>本地家政（管理硬盘）</strong>、<strong>远程快递（跨网传输）</strong>、<strong>逻辑叠罗汉（容器专用）</strong>。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>文件系统</th>
<th>主要角色</th>
<th>核心特点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>本地</strong></td>
<td><strong>EXT4</strong></td>
<td>Linux 标准版</td>
<td>极其稳定，万金油，兼容性好。</td>
<td>大规模并发下性能不如 XFS。</td>
</tr>
<tr>
<td><strong>本地</strong></td>
<td><strong>XFS</strong></td>
<td>Linux 企业版</td>
<td>擅长高并发、海量小文件，Docker 官方最推荐。</td>
<td>缩减容量（shrink）非常困难。</td>
</tr>
<tr>
<td><strong>本地</strong></td>
<td><strong>NTFS</strong></td>
<td>Windows 专用</td>
<td>权限控制极其精细，带日志恢复。</td>
<td>Linux 挂载时性能一般，协议不透明。</td>
</tr>
<tr>
<td><strong>硬件</strong></td>
<td><strong>UFS</strong></td>
<td>移动端&#x2F;嵌入式</td>
<td><strong>手机闪存</strong>的主流标准，读写延迟极低，省电。</td>
<td>主要是硬件接口协议，不适合服务器。</td>
</tr>
<tr>
<td><strong>网络</strong></td>
<td><strong>NFS</strong></td>
<td>远程共享</td>
<td>像文件夹一样挂载远程服务器，配置极简。</td>
<td>依赖网络，<strong>不支持硬链接和原子操作</strong>。</td>
</tr>
<tr>
<td><strong>逻辑</strong></td>
<td><strong>Overlay2</strong></td>
<td>Docker 引擎</td>
<td><strong>不直接存数据</strong>，而是把上面的系统“叠”起来看。</td>
<td>必须跑在支持它的本地系统（EXT4&#x2F;XFS）上。</td>
</tr>
</tbody></table>
<hr>
<h3 id="它们之间的“套娃”关系"><a href="#它们之间的“套娃”关系" class="headerlink" title="它们之间的“套娃”关系"></a>它们之间的“套娃”关系</h3><p>在 Docker 的实际运行中，这些系统是<strong>层级协作</strong>的，而不是互相替代。</p>
<ol>
<li><p><strong>最底层（物理层）</strong>：比如你的手机存储芯片走的是 <strong>UFS</strong> 协议，或者服务器硬盘格式化成了 <strong>XFS</strong>。</p>
</li>
<li><p><strong>中间层（宿主层）</strong>：Linux 内核通过 <strong>VFS</strong> 识别出这是一块 XFS 硬盘。</p>
</li>
<li><p><strong>应用层（Docker 层）</strong>：Docker 启动 <strong>Overlay2</strong> 驱动，在 XFS 的某个文件夹里开始“叠罗汉”（层级镜像）。</p>
</li>
<li><p><strong>数据层（挂载层）</strong>：如果你想让容器里的数据存到另一台机器，你会通过 <strong>NFS</strong> 挂载一个远程目录。</p>
</li>
</ol>
<hr>
<h2 id="不建议在-NFS-上运行-Overlay2-的原因："><a href="#不建议在-NFS-上运行-Overlay2-的原因：" class="headerlink" title="不建议在 NFS 上运行 Overlay2 的原因："></a>不建议在 NFS 上运行 Overlay2 的原因：</h2><h3 id="1-硬链接（Hard-Link）的一致性问题"><a href="#1-硬链接（Hard-Link）的一致性问题" class="headerlink" title="1. 硬链接（Hard Link）的一致性问题"></a>1. 硬链接（Hard Link）的一致性问题</h3><p>Overlay2 在处理镜像层（Layers）时，大量使用了<strong>硬链接</strong>来节省空间和提高效率。</p>
<ul>
<li><strong>NFS 的局限</strong>：在网络环境下，保证跨节点的硬链接一致性非常困难。如果网络出现抖动，NFS 客户端和服务器之间关于硬链接计数的同步可能出错，导致 Docker 镜像层损坏。</li>
</ul>
<h3 id="2-Copy-on-Write-CoW-的性能极差"><a href="#2-Copy-on-Write-CoW-的性能极差" class="headerlink" title="2. Copy-on-Write (CoW) 的性能极差"></a>2. Copy-on-Write (CoW) 的性能极差</h3><p>当容器修改镜像中的文件时，Overlay2 会执行“写时复制”操作：将文件从低层（LowerDir）拷贝到高层（UpperDir）。</p>
<ul>
<li><strong>网络开销</strong>：在本地磁盘（如 EXT4&#x2F;XFS）上，这只是毫秒级的操作。但在 NFS 上，这意味着大量的小文件读写请求要通过网络往返，<strong>延迟（Latency）会放大几十倍</strong>。</li>
</ul>
<h3 id="3-POSIX-兼容性与原子性"><a href="#3-POSIX-兼容性与原子性" class="headerlink" title="3. POSIX 兼容性与原子性"></a>3. POSIX 兼容性与原子性</h3><p>POSIX是Linux VFS的特性<br>Overlay2 依赖于底层文件系统的某些高级 POSIX 特性，例如 <code>whiteout</code>（白点文件，用于标记删除）。</p>
<ul>
<li><strong>不完整支持</strong>：许多 NFS 配置（尤其是旧版本或非标准的 NAS 设备）对 POSIX 特性的支持并不完美。这会导致 Docker 在删除文件或合并层时出现不可预知的报错，最常见的表现就是容器启动时提示 <code>storage driver overlay2: failed to...</code>。</li>
</ul>
<hr>
<h3 id="4-常见的架构对比"><a href="#4-常见的架构对比" class="headerlink" title="4. 常见的架构对比"></a>4. 常见的架构对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>本地文件系统 (EXT4&#x2F;XFS)</th>
<th>网络文件系统 (NFS)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>访问速度</strong></td>
<td><strong>极快</strong> (直接访问内存&#x2F;总线)</td>
<td><strong>慢</strong> (受限于带宽和网络延迟)</td>
</tr>
<tr>
<td><strong>原子性保证</strong></td>
<td>强 (内核层面保证)</td>
<td>弱 (受网络同步机制影响)</td>
</tr>
<tr>
<td><strong>Overlay2 兼容性</strong></td>
<td><strong>完美原生支持</strong></td>
<td><strong>极其不稳定，经常报错</strong></td>
</tr>
</tbody></table>
